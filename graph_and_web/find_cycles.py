from collections import deque
from Cycle import Cycle


def find_cycle_in_list(cycles, cycle_candidate):
    for cycle in cycles:
        if cycle.equal_with(cycle_candidate):
            return cycle
    return None


def init_cycle_candidate(node_list, cycle_len, node_list_len):
    curr_node_name = node_list[0]
    cycle_candidate = deque([curr_node_name])
    node_index = 1
    while len(cycle_candidate) < cycle_len:
        if node_index >= node_list_len:
            return None, -1
        prev_node_name = curr_node_name
        curr_node_name = node_list[node_index]
        node_index += 1
        if prev_node_name != curr_node_name:
            cycle_candidate.append(curr_node_name)
    if node_index >= node_list_len:
        return None, -1
    return cycle_candidate, node_index


def pop_first_in_deque(cycle_deque):
    cycle_deque.popleft()


def cycle_deque_to_list(cycle_deque):
    return list(cycle_deque)


def is_cycle_in_prev_found_cycle(cycle, prev_cycle):
    if not prev_cycle:
        return False
    return prev_cycle[1:] == cycle


def find_all_cycles_of_len(node_list, cycle_len):
    cycles = []
    node_list_len = len(node_list)
    if cycle_len <= node_list_len:
        # Initialize cycle candidate to wanted length
        cycles_candidate_in_deque, node_index = \
            init_cycle_candidate(node_list, cycle_len, node_list_len)

        # Node list was too short
        if cycles_candidate_in_deque is None:
            return cycles

        prev_node_name = cycles_candidate_in_deque[-1]
        curr_node_name = node_list[node_index]
        node_index += 1
        first_cycle = []

        while node_index < node_list_len:
            # Do not show self-loops in cycles
            if prev_node_name != curr_node_name:
                # Cycle test
                if cycles_candidate_in_deque[0] == curr_node_name:
                    cycle_candidate_in_list = cycle_deque_to_list(cycles_candidate_in_deque)
                    if not first_cycle:
                        cycles.append(Cycle(cycle_candidate_in_list))
                        first_cycle = cycle_candidate_in_list
                    elif cycle_candidate_in_list == first_cycle:
                        old_cycle = find_cycle_in_list(cycles, cycle_candidate_in_list)
                        old_cycle.increment_count()
                else:
                    first_cycle = []

                pop_first_in_deque(cycles_candidate_in_deque)
                cycles_candidate_in_deque.append(curr_node_name)

            prev_node_name = curr_node_name
            curr_node_name = node_list[node_index]
            node_index += 1
    return cycles


def filter_cycles_under_threshold(all_cycles, threshold):
    all_filtered_cycles = []
    number_of_cycles = 0
    for cycles in all_cycles:
        filtered_cycles = []
        for cycle in cycles:
            if cycle.count >= threshold:
                filtered_cycles.append(cycle)
                number_of_cycles += 1
        all_filtered_cycles.append(filtered_cycles)
    return all_filtered_cycles, number_of_cycles


def find_cycles_in_range(node_ls, cycle_len1, cycle_len2, cycle_count_threshold):
    all_cycles = []
    number_of_cycles = 0
    for llen in range(cycle_len1, cycle_len2 + 1):
        new_cycles = find_all_cycles_of_len(node_ls, llen)
        number_of_cycles += len(new_cycles)
        all_cycles.append(new_cycles)
    if cycle_count_threshold > 0:
        all_cycles, number_of_cycles = filter_cycles_under_threshold(all_cycles, cycle_count_threshold)
    return all_cycles, number_of_cycles


def is_node_in_a_cycle(all_cycles, node_name):
    for cycles in all_cycles:
        for cycle in cycles:
            if cycle.contains_node(node_name):
                return True
    return False


def are_2_nodes_in_the_same_cycle(all_cycles, node_name1, node_name2):
    for cycles in all_cycles:
        for cycle in cycles:
            if cycle.contains_node(node_name1) and cycle.contains_node(node_name2):
                return True
    return False


if __name__ == '__main__':

    nl = [1, 0, 1, 5, 2, 5, 0, 0, 1, 1, 0, 1, 0, 1, 2, 5, 2, 2, 5, 2, 1, 4]
    allloops, lenl = find_cycles_in_range(nl, 2, 3, 1)

