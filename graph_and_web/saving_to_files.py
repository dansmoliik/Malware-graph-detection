from os import path,makedirs
import ntpath
import properties
from features_search import find_max_number_of_edges_self_loops_node_counts
from find_cycles import are_2_nodes_in_the_same_cycle


def save_data_to_file(file_name, ip_address, what_to_save, data):
    dir_name = path.join("output", "data")
    file_name = ntpath.basename(file_name)
    file_name = file_name.split(".binetflow")[0]
    dir_name = path.join(dir_name, file_name, ip_address)
    if not path.isdir(dir_name):
        makedirs(dir_name)
    file_name_ending = ""
    if what_to_save == "graph_json":
        file_name_ending = "_graph"
        file_name_ending += properties.STR_JSON_EXT
    else:
        if what_to_save == "nodes":
            file_name_ending = "_nodes"
        elif what_to_save == "sl_nodes":
            file_name_ending = "_sl-nodes"
        elif what_to_save == "edges":
            file_name_ending = "_edges"
        elif what_to_save == "cycles":
            file_name_ending = "_cycles"
        elif what_to_save == "overall":
            file_name_ending = "_overall"
        file_name_ending += properties.STR_MD_EXT
    file_name += "_" + ip_address + file_name_ending
    with open(path.join(dir_name, file_name), "w") as f:
        f.write(data)


def save_nodes_to_file(file_name, ip_address, data):
    save_data_to_file(file_name, ip_address, "nodes", data)


def save_sl_nodes_to_file(file_name, ip_address, data):
    save_data_to_file(file_name, ip_address, "sl_nodes", data)


def save_edges_to_file(file_name, ip_address, data):
    save_data_to_file(file_name, ip_address, "edges", data)


def save_cycles_to_file(file_name, ip_address, data):
    save_data_to_file(file_name, ip_address, "cycles", data)


def save_overall_data_to_file(file_name, ip_address, data):
    save_data_to_file(file_name, ip_address, "overall", data)


def save_graph_to_json(file_name, ip_address, node_dict, use_nt, nt, use_slt, slt, use_et, et, all_cycles):
    node_str = ""
    links_str = ""
    max_node_count, max_self_loop_count, max_edge_size = find_max_number_of_edges_self_loops_node_counts(node_dict)
    if max_node_count < properties.GJSON_NODE_MIN_MAX_COUNT:
        max_node_count = properties.GJSON_NODE_MIN_MAX_COUNT
    if max_self_loop_count < properties.GJSON_SELF_LOOP_MIN_MAX_COUNT:
        max_self_loop_count = properties.GJSON_SELF_LOOP_MIN_MAX_COUNT
    if max_edge_size < properties.GJSON_EDGE_MIN_MAX_SIZE:
        max_edge_size = properties.GJSON_EDGE_MIN_MAX_SIZE
    for node_name in node_dict:
        node = node_dict[node_name]
        if use_nt and node.count < nt:
            continue
        node_color_group = properties.GJSON_NODE_DEFAULT_VISUALISATION_COLOR_GROUP
        node_size = \
            properties.GJSON_NODE_VISUALISATION_SIZE_MIN + \
            properties.GJSON_VISULISATION_RANGE_SIZE_OF_NODE_SIZE * node.count / max_node_count
        if node_name in node.edges:  # if node connects to itself -> make node darker
            self_loop_count = len(node.edges[node_name].flows)
            if use_slt and self_loop_count < slt:
                continue
            node_color_group += \
                (properties.GJSON_NODE_DEFAULT_VISUALISATION_COLOR_GROUPS_COUNT - 1) * \
                self_loop_count / max_self_loop_count
        node_str_tmp = '{{"id": "{0}", "node_color_group": {1}, "node_size": {2}}},\n'\
            .format(node_name, node_color_group, node_size)
        for dst_node_name in node.edges:
            if dst_node_name != node_name:
                dst_node = node_dict[dst_node_name]
                if use_nt and dst_node.count < nt:
                    continue
                if dst_node in dst_node.edges:
                    if use_slt and len(dst_node.edges[dst_node]):
                        continue
                edge_repetition = len(node.edges[dst_node_name].flows)
                if use_et and edge_repetition < et:
                    continue
                edge_size = \
                    properties.GJSON_EDGE_VISUALISATION_SIZE_MIN + \
                    properties.GJSON_VISULISATION_RANGE_SIZE_OF_EDGE_SIZE * \
                    edge_repetition / max_edge_size
                dst_node_size = properties.GJSON_NODE_VISUALISATION_SIZE_MIN + \
                    properties.GJSON_VISULISATION_RANGE_SIZE_OF_NODE_SIZE * \
                    node_dict[dst_node_name].count / max_node_count
                edge_color_group = properties.GJSON_EDGE_DEFAULT_VISUALISATION_COLOR_GROUP
                if are_2_nodes_in_the_same_cycle(all_cycles, node_name, dst_node_name):
                    edge_color_group = properties.GJSON_EDGE_IN_CYCLE_VISUALISATION_COLOR_GROUP
                links_str += '{{"source": "{0}", "target": "{1}", "value": {2}, "dst_node_size": {3}, ' \
                    '"edge_color_group": {4}}},\n'\
                    .format(node_name, dst_node_name, edge_size, dst_node_size, edge_color_group)
        node_str += node_str_tmp
    node_str = node_str[:-2]
    links_str = links_str[:-2]
    graph_json_str = '{{"nodes":[\n{0}\n],\n "links":[\n{1}\n]}}'.format(node_str, links_str)
    save_data_to_file(file_name, ip_address, "graph_json", graph_json_str)
    return graph_json_str


def save_group_features_to_file(file_name, data):
    if path.isfile(file_name):
        mod = "a"
    else:
        mod = "w"
    file_name += properties.STR_CSV_EXT
    with open(file_name, mod) as f:
        f.write(data)
