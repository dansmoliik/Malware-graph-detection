import sys
from other_functions import get_next_flow_index

cycles = []


def visited(node, path):
    return node in path


def index_of_smallest(path):
    smallest_i = 0
    i = 0
    for node in path:
        if node.node_name < path[smallest_i].node_name:
            smallest_i = i
        i += 1
    return smallest_i


def equals(path1, path2):
    if len(path1) != len(path2):
        return False
    for i in range(0, len(path1)):
        if path1[i].node_name != path2[i].node_name:
            return False
    return True


def normalize(path):
    smallest_i = index_of_smallest(path)
    p_len = len(path)
    return path[-(p_len - smallest_i):] + path[0:smallest_i]


def is_new(path):
    for p in cycles:
        if equals(p, path):
            return False
    return True


def find_all_loops_of_len(node_dict, first_node, loop_len):
    loops = []
    loop_candidates = [first_node]
    curr_node = first_node
    flow_index = 0
    if (loop_len - 1) < len(node_dict):
        while len(loop_candidates) != loop_len:
            if flow_index == sys.maxint:
                return []
            prev_node = curr_node
            curr_node = node_dict[curr_node.next_node_name(flow_index)]
            flow_index = get_next_flow_index(node_dict, curr_node, flow_index)
            if prev_node.node_name != curr_node.node_name:
                loop_candidates.append(curr_node.node_name)
        while flow_index != sys.maxint:
            if len(loop_candidates) == loop_len:
                if loop_candidates[-1] == loop_candidates[0]:
                    loops.append(loop_candidates)
                loop_candidates = loop_candidates[1:]
            prev_node = curr_node
            curr_node = node_dict[curr_node.next_node_name(flow_index)]
            flow_index = get_next_flow_index(node_dict, curr_node, flow_index)
            if prev_node.node_name != curr_node.node_name:
                loop_candidates.append(curr_node.node_name)
    return loops


def find_all_loops(node_dict):
    def find_new_cycles(path):
        first_node = path[0]
        curr_node = path[-1]
        for node_neighbour_name in curr_node.edges:
            neighbour_node = node_dict[node_neighbour_name]
            if visited(neighbour_node, path):
                p = normalize(path)
                if node_neighbour_name == first_node.node_name \
                        and is_new(p):
                    cycles.append(p)
            else:
                new_path = list(path)
                new_path.append(neighbour_node)
                find_new_cycles(new_path)

    for node_name in node_dict:
        find_new_cycles([node_dict[node_name]])
    return cycles


def is_node_in_a_loop(node_name, loops):
    for loop in loops:
        if len(loop) > 1:
            for node_from_loop in loop:
                if node_from_loop.node_name == node_name:
                    return True
    return False

if __name__ == "__main__":
    print len("gsgfgf".split(","))
