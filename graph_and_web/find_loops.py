cycles = []


def visited(node, path):
    return node in path


def index_of_smallest(path):
    smallest_i = 0
    i = 0
    for node in path:
        if node.node_name < path[smallest_i].node_name:
            smallest_i = i
        i += 1
    return smallest_i


def equals(path1, path2):
    if len(path1) != len(path2):
        return False
    for i in range(0, len(path1)):
        if path1[i].node_name != path2[i].node_name:
            return False
    return True


def normalize(path):
    smallest_i = index_of_smallest(path)
    p_len = len(path)
    return path[-(p_len - smallest_i):] + path[0:smallest_i]


def is_new(path):
    for p in cycles:
        if equals(p, path):
            return False
    return True


def find_all_loops(node_dict):
    def find_new_cycles(path):
        first_node = path[0]
        curr_node = path[-1]
        for node_neighbour_name in curr_node.edges:
            neighbour_node = node_dict[node_neighbour_name]
            if visited(neighbour_node, path):
                p = normalize(path)
                if node_neighbour_name == first_node.node_name \
                        and is_new(p):
                    cycles.append(p)
            else:
                new_path = list(path)
                new_path.append(neighbour_node)
                find_new_cycles(new_path)

    for node_name in node_dict:
        find_new_cycles([node_dict[node_name]])
    return cycles


def is_node_in_a_loop(node_name, loops):
    for loop in loops:
        if len(loop) > 1:
            for node_from_loop in loop:
                if node_from_loop.node_name == node_name:
                    return True
    return False

if __name__ == "__main__":
    a = ["aaa"]
    b = 'aaa'
    print b in a
