from Loop import Loop


def equals(path1, path2):
    if len(path1) != len(path2):
        return False
    for i in range(0, len(path1)):
        if path1[i] != path2[i]:
            return False
    return True


def find_loop_in_list(loops, loop_candidate):
    for loop in loops:
        if loop.equal_with(loop_candidate):
            return loop
    return None


def loop_to_normal_form(loop_candidate):
    min_node_name = min(loop_candidate)
    min_node_name_i = loop_candidate.index(min_node_name)
    return loop_candidate[min_node_name_i:] + loop_candidate[:min_node_name_i]


def fill_loop_candidate(node_list, node_i, loop_candidate, loop_len, max_i):
    if len(loop_candidate) > 0:
        prev_node_name = loop_candidate[-1]
    else:
        prev_node_name = ""
    curr_node_name = node_list[node_i]
    node_i += 1
    while len(loop_candidate) < loop_len:
        if node_i >= max_i:
            return [], "", "", -1
        if prev_node_name != curr_node_name:
            loop_candidate.append(curr_node_name)
        prev_node_name = curr_node_name
        curr_node_name = node_list[node_i]
        node_i += 1
        print loop_candidate, node_i
    return loop_candidate, prev_node_name, curr_node_name, node_i


def find_all_loops_of_len(node_list, loop_len):
    loops = []
    print loop_len
    if loop_len <= len(node_list):
        loop_candidate = []
        node_index = 0
        node_list_len = len(node_list)
        loop_candidate, prev_node_name, curr_node_name, node_index = \
            fill_loop_candidate(node_list, node_index, loop_candidate, loop_len, node_list_len)

        if not loop_candidate:
            return loop_candidate

        print loop_candidate, prev_node_name, curr_node_name, node_index
        while node_index < node_list_len:
            prev_node_name = curr_node_name
            curr_node_name = node_list[node_index]
            node_index += 1

            if prev_node_name == curr_node_name:
                continue

            if loop_candidate[0] == curr_node_name:

                print loop_candidate, curr_node_name
                loop_candidate_norm = loop_to_normal_form(loop_candidate)
                old_loop = find_loop_in_list(loops, loop_candidate_norm)
                if old_loop is None:
                    print "new"
                    loops.append(Loop(loop_candidate_norm))
                else:
                    print "old"
                    old_loop.increment_count()
            loop_candidate = loop_candidate[1:]
            loop_candidate.append(curr_node_name)
    return loops


def filter_loops_under_threshold(all_loops, threshold):
    all_filtered_loops = []
    number_of_loops = 0
    for loops in all_loops:
        filtered_loops = []
        for loop in loops:
            if loop.count >= threshold:
                filtered_loops.append(loop)
                number_of_loops += 1
        all_filtered_loops.append(filtered_loops)
    return all_filtered_loops, number_of_loops


def get_loops_in_range(node_ls, loop_len1, loop_len2, loop_count_threshold):
    all_loops = []
    number_of_loops = 0
    for llen in range(loop_len1, loop_len2 + 1):
        new_loops = find_all_loops_of_len(node_ls, llen)
        number_of_loops += len(new_loops)
        all_loops.append(new_loops)
    if loop_count_threshold > 0:
        all_loops, number_of_loops = filter_loops_under_threshold(all_loops, loop_count_threshold)
    return all_loops, number_of_loops

if __name__ == '__main__':
    nums = range(0, 10)
    strs = ["abc", "ab", "ba", "c", "b"]
    min_e = min(strs)
    min_e_i = strs.index(min_e)
    print strs[min_e_i:] + strs[:min_e_i]