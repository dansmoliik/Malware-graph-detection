import sys
from os import path, makedirs
import ntpath
import filter_data
from make_graph import mk_graph, save_graph_to_json
from other_functions import is_number
from find_loops import find_all_loops_of_len


def print_list_node_names_counts(nodes, counts):
    print "---------------"
    for i in range(0, len(nodes)):
        print "{:<30}{:>10}".format(nodes[i], counts[i])
    print "---------------\n"


def save_nodes_to_file(file_name, nodes, counts):
    data = ""
    for i in range(0, len(nodes)):
        data += "{:<30}{:>10}\n".format(nodes[i], counts[i])
    dir_name = path.join("output", file_name)
    if not path.isdir(dir_name):
        makedirs(dir_name)
    file_name = ntpath.basename(file_name)
    file_name_splits = file_name.split(".binetflow")
    file_name = file_name_splits[0] + "_nodes" + ".md"
    with open(path.join(dir_name, file_name), "w") as f:
        f.write(data)


def print_list_edges_counts(src_nodes, dst_nodes, counts):
    print "---------------"
    for i in range(0, len(src_nodes)):
        print "{:<30}=>{:>30}".format(src_nodes[i], dst_nodes[i]), "{:>10}".format(counts[i])
    print "---------------\n"


def save_edges_to_file(file_name, src_nodes, dst_nodes, counts):
    data = ""
    for i in range(0, len(src_nodes)):
        data += "{:<30}=>{:>30}{:>10}\n".format(src_nodes[i], dst_nodes[i], counts[i])
    dir_name = path.join("output", file_name)
    if not path.isdir(dir_name):
        makedirs(dir_name)
    file_name = ntpath.basename(file_name)
    file_name_splits = file_name.split(".binetflow")
    file_name = file_name_splits[0] + "_edges" + ".md"
    with open(path.join(dir_name, file_name), "w") as f:
        f.write(data)


def is_numerical_argument_valid(arg_i, args, argc):
    if arg_i >= argc:
        return False
    return is_number(args[arg_i])


def raise_wrong_input_exception(arg):
    raise Exception("Wrong input argument at {}.".format(arg))


def are_filter_args_valid(arg_i, args, argc):
    if arg_i >= argc:
        return False
    if args[arg_i].startswith("-"):
        return False
    filter_args = args[arg_i].split("|")
    for arg in filter_args:
        split_args = arg.split(",")
        if len(split_args) == 1:
            return is_number(arg) or not arg.startswith("-")
        elif len(split_args) == 2:
            return is_number(split_args[0]) and not is_number(split_args[1])
        else:
            return False


def process_input_args(args):
    filter_nodes_with_one_occurrence = False
    filter_args = ""
    alt = et = -1
    llen = -1
    argc = len(args)
    arg_i = 3
    error_happened = False
    while arg_i < argc:
        curr_arg = args[arg_i]
        if curr_arg == "-f1":
            filter_nodes_with_one_occurrence = True
        elif curr_arg == "-f":
            if are_filter_args_valid(arg_i + 1, args, argc):
                arg_i += 1
                filter_args = args[arg_i]
            else:
                error_happened = True
        elif curr_arg == "-alt":
            if is_numerical_argument_valid(arg_i + 1, args, argc):
                arg_i += 1
                alt = int(args[arg_i])
            else:
                error_happened = True
        elif curr_arg == "-et":
            if is_numerical_argument_valid(arg_i + 1, args, argc):
                arg_i += 1
                et = int(args[arg_i])
            else:
                error_happened = True
        elif curr_arg == "-llen":
            if is_numerical_argument_valid(arg_i + 1, args, argc):
                arg_i += 1
                llen = int(args[arg_i])
            else:
                error_happened = True

        if error_happened:
            raise_wrong_input_exception(args[arg_i])
        arg_i += 1
    return filter_nodes_with_one_occurrence, filter_args, alt, et, llen


if __name__ == "__main__":
    if len(sys.argv) >= 3:
        file_name = path.join('data', sys.argv[1])
        ip_address = sys.argv[2]
        data = filter_data.read_and_filter_file_only_examined_src_ip(file_name, ip_address)

        filter_nodes_with_one_occurrence, filter_args, alt, et, llen = process_input_args(sys.argv)

        node_dict, first_node = mk_graph(data, filter_args)

        prev_len = len(node_dict)
        print "Total number of nodes:", prev_len
        if filter_nodes_with_one_occurrence:
            node_dict = filter_data.filter_nodes(node_dict)
            print "Removed", prev_len - len(node_dict), "/", prev_len, "nodes"

        # -------------------------------------
        # tn = [first_node.node_name]
        # flow_index = 0
        # curr_node = first_node
        # while flow_index != sys.maxint:
        #     curr_node = node_dict[curr_node.next_node_name(flow_index)]
        #     flow_index = get_next_flow_index(node_dict, curr_node, flow_index)
        #     if not curr_node.node_name in tn:
        #         tn.append(curr_node.node_name)

        if llen > -1:
            loops = find_all_loops_of_len(node_dict, first_node, llen)
            print "Number of loops of length", llen, ":", len(loops)
            print "Loop of length", llen
            for loop in loops:
                print loop

        # -------------------------------------

        al_nodes, al_counts = filter_data.find_auto_looping_nodes_and_counts(node_dict, alt)
        edge_src_nodes, edge_dst_nodes, e_counts = \
            filter_data.find_nodes_with_edge_size(node_dict, et)
        if alt > -1:
            print "Number of autolooping nodes above threshold: ", len(al_nodes)
            print "Nodes above threshold with autolooping counts above threshold", alt
            print_list_node_names_counts(al_nodes, al_counts)
            save_nodes_to_file(file_name, al_nodes, al_counts)
        if et > -1:
            print "Nodes with edge number above threshold", et
            print_list_edges_counts(edge_src_nodes, edge_dst_nodes, e_counts)
            save_edges_to_file(file_name, edge_src_nodes, edge_dst_nodes, e_counts)

        save_graph_to_json(node_dict)
    else:
        print "There should be 2 input arguments:\n" \
              "name of .binetflow (with file extension) file (from \"data\" directory)\n" \
              "and an IP address.\n"
