import sys
from os import path, makedirs
import ntpath
import filter_data
from make_graph import mk_graph, save_graph_to_json
from input_processing import process_input_args
from find_loops import get_loops_in_range


def print_list_node_names_counts(nodes, counts):
    print "---------------"
    for i in range(0, len(nodes)):
        print "{:<30}{:>10}".format(nodes[i], counts[i])
    print "---------------\n"


def save_nodes_to_file(file_name, ip_address, nodes, counts):
    data = ""
    for i in range(0, len(nodes)):
        data += "{:<30}{:>10}\n".format(nodes[i], counts[i])
    dir_name = path.join("output", file_name)
    if not path.isdir(dir_name):
        makedirs(dir_name)
    dir_name = path.join(dir_name, ip_address)
    if not path.isdir(dir_name):
        makedirs(dir_name)
    file_name = ntpath.basename(file_name)
    file_name_splits = file_name.split(".binetflow")
    file_name = file_name_splits[0] + "_nodes" + ".md"
    with open(path.join(dir_name, file_name), "w") as f:
        f.write(data)


def print_list_edges_counts(src_nodes, dst_nodes, counts):
    print "---------------"
    for i in range(0, len(src_nodes)):
        print "{:<30}=>{:>30}".format(src_nodes[i], dst_nodes[i]), "{:>10}".format(counts[i])
    print "---------------\n"


def save_edges_to_file(file_name, ip_address, src_nodes, dst_nodes, counts):
    data = ""
    for i in range(0, len(src_nodes)):
        data += "{:<30}=>{:>30}{:>10}\n".format(src_nodes[i], dst_nodes[i], counts[i])
    dir_name = path.join("output", file_name)
    if not path.isdir(dir_name):
        makedirs(dir_name)
    dir_name = path.join(dir_name, ip_address)
    if not path.isdir(dir_name):
        makedirs(dir_name)
    file_name = ntpath.basename(file_name)
    file_name_splits = file_name.split(".binetflow")
    file_name = file_name_splits[0] + "_edges" + ".md"
    with open(path.join(dir_name, file_name), "w") as f:
        f.write(data)

if __name__ == "__main__":
    if len(sys.argv) >= 3:
        file_name = path.join('data', sys.argv[1])
        ip_address = sys.argv[2]
        data = filter_data.read_and_filter_file_only_examined_src_ip(file_name, ip_address)

        filter_nodes_with_one_occurrence, filter_args, alt, et, llen1, llen2, lt \
            = process_input_args(sys.argv)

        node_dict, first_node, nodes_ls_in_order = mk_graph(data, filter_args)

        prev_len = len(node_dict)

        # -------------------------------------
        # Filtering all nodes that appeared only once
        print "Total number of nodes:", prev_len
        if filter_nodes_with_one_occurrence:
            node_dict, nodes_ls_in_order = filter_data.filter_nodes(node_dict, nodes_ls_in_order)
            print "Removed", prev_len - len(node_dict), "/", prev_len, "nodes"

        # -------------------------------------
        # Autolooping nodes above threshold
        al_nodes, al_counts = filter_data.find_auto_looping_nodes_and_counts(node_dict, alt)
        if alt > -1:
            print "Number of autolooping nodes above threshold: ", len(al_nodes)
            print "Nodes above threshold with autolooping counts above threshold", alt
            print_list_node_names_counts(al_nodes, al_counts)
            save_nodes_to_file(file_name, ip_address, al_nodes, al_counts)

        # -------------------------------------
        # Edges with size above threshold
        edge_src_nodes, edge_dst_nodes, e_counts = \
            filter_data.find_nodes_with_edge_size(node_dict, et)
        if et > -1:
            print "Nodes with edge number above threshold", et
            print_list_edges_counts(edge_src_nodes, edge_dst_nodes, e_counts)
            save_edges_to_file(file_name, ip_address, edge_src_nodes, edge_dst_nodes, e_counts)

        # -------------------------------------
        # Loops of given range above given count threshold
        if llen1 > 1:
            all_loops, number_of_loops = get_loops_in_range(node_dict, nodes_ls_in_order, llen1, llen2, lt)
            loop_len = llen1
            print "Total number of loops in range {} - {} above count threshold {} is: {}"\
                .format(llen1, llen2, lt, number_of_loops)
            for loops in all_loops:
                number_of_loops = len(loops)
                if number_of_loops > 1:
                    print "------------------------------------------------------------------------"
                    print "Loops of length {} ({}):".format(loop_len, number_of_loops)
                    for loop in loops:
                        print loop
                    print "------------------------------------------------------------------------"
                loop_len += 1

        save_graph_to_json(node_dict)
    else:
        print "There should be at least 2 input arguments:\n" \
              "name of .binetflow (with file extension) file (from \"data\" directory)\n" \
              "and an IP address.\n"
