import sys
from os import path
import properties
from other_functions import console_print


def read_and_filter_file_only_examined_src_ip(file_name, src_ip_address):
    if not path.isfile(file_name):
        return "error"
    file_content = ""
    with open(file_name, "r") as f:
        f.readline()
        for line in f:
            line_splits = line.split(",")
            if len(line_splits) > 1:
                ip_address = line_splits[properties.FLOW_SRC_ADDR_I]
                if ip_address == src_ip_address:
                    file_content += line
    return file_content


def filter_nodes(node_dict, node_ls_in_order):
    new_node_dict = {}
    for curr_node_name in node_dict.keys():
        curr_node = node_dict[curr_node_name]
        if curr_node.count == 1:

            index_of_node = node_ls_in_order.index(curr_node_name)
            node_ls_in_order.pop(index_of_node)

            if len(curr_node.parents) == 0:
                edge = curr_node.edges
                if len(edge) != 0:
                    child_node_name = edge.keys().pop()
                    child_node = node_dict[child_node_name]
                    parent_index = child_node.parents.index(curr_node_name)
                    del child_node.parents[parent_index]
            elif len(curr_node.edges) == 0:
                parent_name = curr_node.parents.pop()
                parent_node = node_dict[parent_name]
                del parent_node.edges[curr_node_name]
            else:
                edge = curr_node.edges
                child_name = edge.keys().pop()
                child_node = node_dict[child_name]
                parent_index = child_node.parents.index(curr_node_name)
                del child_node.parents[parent_index]
                parent_name = curr_node.parents.pop()
                parent_node = node_dict[parent_name]
                flow_index = parent_node.edges[curr_node_name].flows.keys().pop()
                del parent_node.edges[curr_node_name]

                parent_node.add_new_flow(child_name, "", flow_index)
                child_node.add_parent(parent_name)

        else:
            new_node_dict[curr_node_name] = node_dict[curr_node_name]
    return new_node_dict, node_ls_in_order


def filter_protocol_or_port(line_str, filter_args_str):
    filter_args = filter_args_str.split("|")
    line = line_str.split(",")

    for arg in filter_args:
        split_args = arg.split(",")
        if len(split_args) == 1:
            if line[properties.FLOW_PROTO_I] == arg or line[properties.FLOW_D_PORT_I] == arg:
                return True
        elif len(split_args) == 2:
            if line[properties.FLOW_D_PORT_I] == split_args[0] and line[properties.FLOW_PROTO_I] == split_args[1]:
                return True
    return False


def create_filtered_data_file_name(file_name):
    return file_name.split(".binetflow")[0] + "_filtered.binetflow"


def save_filtered_data(file_name, data):
    with open(file_name, "w") as f:
        f.write(data)

if __name__ == "__main__":
    if len(sys.argv) == 3:
        file_name = path.join("data", sys.argv[1])
        ip_address = sys.argv[2]
        filtered_data = read_and_filter_file_only_examined_src_ip(file_name, ip_address)
        new_file_name = file_name = create_filtered_data_file_name(file_name)
        save_filtered_data(new_file_name, filtered_data)
        console_print("Filtered data saved\n")
    else:
        console_print("There should be 2 input arguments:\n"
                      "name of .binetflow (with file extension) file (from \"data\" directory)\n"
                      "and an IP address.\n")
