import sys
from os import path
import properties


def read_and_filter_file_only_examined_src_ip(file_name, src_ip_address):
    with open(file_name, "r") as f:
        file_content = ""
        f.readline()
        for line in f:
            ip_address = line.split(",")[properties.SRC_ADDR_I]
            if ip_address == src_ip_address:
                file_content += line
    return file_content


def filter_nodes(node_dict):
    new_node_dict = {}
    for curr_node_name in node_dict.keys():
        curr_node = node_dict[curr_node_name]
        if curr_node.count == 1:
            if len(curr_node.parents) == 0:
                edge = curr_node.edges
                child_node_name = edge.keys().pop()
                child_node = node_dict[child_node_name]
                parent_index = child_node.parents.index(curr_node_name)
                del child_node.parents[parent_index]
            elif len(curr_node.edges) == 0:
                parent_name = curr_node.parents.pop()
                parent_node = node_dict[parent_name]
                del parent_node.edges[curr_node_name]
            elif len(curr_node.parents) == 1 and len(curr_node.edges) == 1:
                edge = curr_node.edges
                child_name = edge.keys().pop()
                child_node = node_dict[child_name]
                parent_index = child_node.parents.index(curr_node_name)
                del child_node.parents[parent_index]
                parent_name = curr_node.parents.pop()
                parent_node = node_dict[parent_name]
                del parent_node.edges[curr_node_name]

                parent_node.add_connection_from_filtering(child_name)
                child_node.add_parent(parent_name)

        else:
            new_node_dict[curr_node_name] = node_dict[curr_node_name]
    return new_node_dict


def filter_graph(node_dict):
    return filter_nodes(node_dict)


def find_auto_looping_nodes_and_counts(node_dict, threshold):
    wanted_nodes = []
    counts = []
    for node_name in node_dict:
        node = node_dict[node_name]
        if node_name in node.edges.keys() and len(node.edges[node_name].flows) >= threshold:
            wanted_nodes.append(node_name)
            counts.append(len(node.edges[node_name].flows))
    return wanted_nodes, counts


def find_nodes_with_edge_size(node_dict, threshold):
    src_nodes = []
    dst_nodes = []
    counts = []
    for node_name in node_dict:
        node = node_dict[node_name]
        for edge_dst in node.edges:
            if edge_dst != node_name and len(node.edges[edge_dst].flows) >= threshold:
                src_nodes.append(node_name)
                dst_nodes.append(edge_dst)
                counts.append(len(node.edges[edge_dst].flows))
    return src_nodes, dst_nodes, counts


def create_filtered_data_file_name(file_name):
    return file_name.split(".binetflow")[0] + "_filtered.binetflow"


def save_filtered_data(file_name, data):
    with open(file_name, "w") as f:
        f.write(data)

if __name__ == "__main__":
    if len(sys.argv) == 3:
        file_name = path.join("data", sys.argv[1])
        ip_address = sys.argv[2]
        filtered_data = read_and_filter_file_only_examined_src_ip(file_name, ip_address)
        new_file_name = file_name = create_filtered_data_file_name(file_name)
        save_filtered_data(new_file_name, filtered_data)
        print "Filtered data saved\n"
    else:
        print "There should be 2 input arguments:\n" \
              "name of .binetflow (with file extension) file (from \"data\" directory)\n" \
              "and an IP address.\n"
