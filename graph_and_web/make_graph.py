import properties
from Node import Node
from filter_data import filter_protocol_or_port

node_dict = None


def create_node_name(line):
    line_splits = line.split(",")
    dst_addr = line_splits[properties.DST_ADDR_I]
    d_port = line_splits[properties.D_PORT_I]
    proto = line_splits[properties.PROTO_I]
    return '{0}-{1}-{2}'.format(dst_addr, d_port, proto)


def find_max_number_of_edges(node_dict):
    max_flows_to_self = 0
    max_flows_number = 0
    max_node_count = 0
    for node_name in node_dict:
        node = node_dict[node_name]
        if node_name in node.edges:
            flows_to_self = len(node.edges[node_name].flows)
            if max_flows_to_self < flows_to_self:
                max_flows_to_self = flows_to_self
        if max_node_count < node.count:
            max_node_count = node.count
        for edge_dst in node.edges:
            flows_number = len(node.edges[edge_dst].flows)
            if max_flows_number < flows_number:
                max_flows_number = flows_number
    return max_node_count, max_flows_to_self, max_flows_number


def save_graph_to_json(node_dict, loops=[[]]):
    node_str = ""
    links_str = ""
    max_node_count, max_flows_to_self, max_flows_number = find_max_number_of_edges(node_dict)
    for node_name in node_dict:
        node = node_dict[node_name]
        node_color_group = 0
        node_size = 5 + 10 * node.count / max_node_count
        if node_name in node.edges:  # if node connects to itself -> make node darker
            node_color_group += 5 * len(node.edges[node_name].flows) / max_flows_to_self
        node_str += '{{"id": "{0}", "node_color_group": {1}, "node_size": {2}}},\n'\
            .format(node_name, node_color_group, node_size)
        for edge_dst in node.edges:
            if edge_dst != node_name:
                edge_size = 1 + 150 * len(node.edges[edge_dst].flows) / max_flows_number
                dst_node_size = 5 + 10 * node_dict[edge_dst].count / max_node_count
                # if find_loops.is_node_in_a_loop(edge_dst, loops):
                #     edge_color_group = 1
                # else:
                edge_color_group = 0
                links_str += '{{"source": "{0}", "target": "{1}", "value": {2}, "dst_node_size": {3}, ' \
                             '"edge_color_group": {4}}},\n'\
                    .format(node_name, edge_dst, edge_size, dst_node_size, edge_color_group)
    node_str = node_str[:-2]
    links_str = links_str[:-2]
    graph_json_str = '{{"nodes":[\n{0}\n],\n "links":[\n{1}\n]}}'.format(node_str, links_str)
    with open("graph.json", "w") as f:
        f.write(graph_json_str)
    return graph_json_str


def mk_graph(data, filter_args_str):
    if data == "":
        return {}, None
    line, data_rest = data.split("\n", 1)
    node_name = create_node_name(line)
    first_node = curr_node = Node(node_name)
    first_node.count = 1
    node_dict = {node_name: curr_node}

    nodes_ls_in_order = [node_name]

    edges_count = 0
    for line in data_rest.splitlines():
        if not filter_protocol_or_port(line, filter_args_str):
            node_name = create_node_name(line)
            nodes_ls_in_order.append(node_name)
            if not node_name in node_dict:
                node_dict[node_name] = Node(node_name)
            next_node = node_dict[node_name]
            curr_node.add_new_flow(node_name, line, edges_count)
            next_node.increment_count()
            next_node.add_parent(curr_node.node_name)
            curr_node = next_node
            edges_count += 1

    return node_dict, first_node, nodes_ls_in_order
