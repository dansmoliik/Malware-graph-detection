import sys
from os import path
import filter_data
import properties
from Node import Node


def are_data_filtered(file_name):
    return len(file_name.split("_filtered.binetflow")) == 2


def handle_unfiltered_data(file_name, src_ip_address):
    data = filter_data.read_and_filter_file(file_name, src_ip_address)
    filtered_data_file_name = filter_data.create_filtered_data_file_name(file_name)
    filter_data.save_filtered_data(filtered_data_file_name, data)
    return filtered_data_file_name


def create_node_name(line):
    line_splits = line.split(",")
    dst_addr = line_splits[properties.DST_ADDR_I]
    d_port = line_splits[properties.D_PORT_I]
    proto = line_splits[properties.PROTO_I]
    return '{0}-{1}-{2}'.format(dst_addr, d_port, proto)


def find_max_number_of_edges(node_dict):
    max_flows_to_self = 0
    max_flows_number = 0
    max_node_count = 0
    for node_name in node_dict:
        node = node_dict[node_name]
        if node_name in node.edges:
            flows_to_self = len(node.edges[node_name].flows)
            if max_flows_to_self < flows_to_self:
                max_flows_to_self = flows_to_self
        if max_node_count < node.count:
            max_node_count = node.count
        for edge_dst in node.edges:
            flows_number = len(node.edges[edge_dst].flows)
            if max_flows_number < flows_number:
                max_flows_number = flows_number
    return max_node_count, max_flows_to_self, max_flows_number


def save_graph_to_json(node_dict):
    node_str = ""
    links_str = ""
    max_node_count, max_flows_to_self, max_flows_number = find_max_number_of_edges(node_dict)
    print max_node_count, max_flows_to_self, max_flows_number
    for node_name in node_dict:
        node = node_dict[node_name]
        node_color_group = 0
        node_size = 5 + 10 * node.count / max_node_count
        if node_name in node.edges:  # if node connects to itself -> make node darker
            node_color_group += 5 * len(node.edges[node_name].flows) / max_flows_to_self
        node_str += '{{"id": "{0}", "node_color_group": {1}, "node_size": {2}}},\n'\
            .format(node_name, node_color_group, node_size)
        for edge_dst in node.edges:
            if edge_dst != node_name:
                edge_size = 1 + 150 * len(node.edges[edge_dst].flows) / max_flows_number
                dst_node_size = 5 + 10 * node_dict[edge_dst].count / max_node_count
                links_str += '{{"source": "{0}", "target": "{1}", "value": {2}, "dst_node_size": {3}}},\n'\
                    .format(node_name, edge_dst, edge_size, dst_node_size)
    node_str = node_str[:-2]
    links_str = links_str[:-2]
    graph_json_str = '{{"nodes":[\n{0}\n],\n "links":[\n{1}\n]}}'.format(node_str, links_str)
    with open("graph.json", "w") as f:
        f.write(graph_json_str)
    return graph_json_str


def mk_graph(file_name):
    with open(file_name, "r") as f:
        f.readline()
        line = f.readline()
        node_name = create_node_name(line)
        first_node = curr_node = Node(node_name)
        first_node.count = 1
        node_dict = {node_name: curr_node}

        flows_ls_chrono = []

        edges_count = 0
        for line in f:
            node_name = create_node_name(line)
            flows_ls_chrono.append(node_name)
            if not node_name in node_dict:
                node_dict[node_name] = Node(node_name)
            next_node = node_dict[node_name]
            curr_node.add_new_flow(node_name, line, edges_count)
            next_node.increment_count()
            curr_node = next_node
            edges_count += 1

    save_graph_to_json(node_dict)
    return node_dict, first_node

if __name__ == "__main__":
    if len(sys.argv) == 3:
        file_name = path.join('data', sys.argv[1])
        ip_address = sys.argv[2]
        if not are_data_filtered(file_name):
            file_name = handle_unfiltered_data(file_name, ip_address)

        mk_graph(file_name)
    else:
        print "There should be 2 input arguments:\n" \
              "name of .binetflow (with file extension) file (from \"data\" directory)\n" \
              "and an IP address.\n"
